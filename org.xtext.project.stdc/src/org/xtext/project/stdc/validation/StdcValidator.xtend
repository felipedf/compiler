/*
 * generated by Xtext 2.9.2
 */
package org.xtext.project.stdc.validation

import org.eclipse.xtext.validation.Check
import org.xtext.project.stdc.stdc.AssignmentExpression
import org.xtext.project.stdc.stdc.DeclarationInitDeclaratorList
import org.xtext.project.stdc.stdc.DirectDeclarator
import org.xtext.project.stdc.stdc.ExpressionC
import org.xtext.project.stdc.stdc.FunctionCall
import org.xtext.project.stdc.stdc.FunctionDefinition
import org.xtext.project.stdc.stdc.Identifier
import org.xtext.project.stdc.stdc.PostfixExpression
import org.xtext.project.stdc.stdc.StdcPackage
import org.xtext.project.stdc.stdc.TypeSpecifier

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.xtext.project.stdc.validation.StdcUtil.*
import org.xtext.project.stdc.stdc.FunctionParametersDecl
import org.xtext.project.stdc.stdc.DoWhileLoop
import org.xtext.project.stdc.stdc.InitDeclaList
import org.xtext.project.stdc.stdc.Initializer

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class StdcValidator extends AbstractStdcValidator {
			
	public static val INVALID_NAME = 'invalidName'
	public static val DUPLICATE_ELEMENT = ' There is a variable name conflict'
	public static val FUNCTION_DUPLICATE = ' There is another method with same name'

	@Check
	def checkExistReturn(FunctionDefinition f) {
		var nReturns = f.returnStatement.size;
		val ftype = f.declarationSpec.filter(typeof(TypeSpecifier)).head.type
		if(nReturns == 0 && ftype != 'void') {
			error('Method should have a return',StdcPackage.Literals.FUNCTION_DEFINITION__BODY,
				INVALID_NAME)
		}
	}
	
	@Check
	def checkFunctionParameters(FunctionCall fc) {
		var parameters = fc.params
		val primaryExp = fc.containingPostfixExpression.primaryExp
		if(primaryExp == null || !(primaryExp instanceof Identifier) ) {
			error("The function name should be an Identifier.",
					StdcPackage.Literals.FUNCTION_CALL__PARAMS,
							INVALID_NAME)
		}

		val fname = (primaryExp as Identifier).name
		val fcall = fc.containingClass.exDeclaration.
			filter(typeof(FunctionDefinition)).findFirst[
				it.decla.directDecl.name == fname
		]
		if(fcall == null) {
			error("The function '"+fname+"' was not declared yet.",
						StdcPackage.Literals.FUNCTION_CALL__PARAMS,
							INVALID_NAME)
		}
		val params = fcall.decla.
			getAllContentsOfType(typeof(FunctionParametersDecl)).head.params


		if(params.size != parameters.size) {
			error("Number of parameters are diferent. Expected '"
				+params.size+"' parameter(s) but only found '"+parameters.size+"'",
								StdcPackage.Literals.FUNCTION_CALL__PARAMS,
								INVALID_NAME)			
		}

		for(var p=0; p<params.length && p<parameters.length; p++) {
			var typeDecl = params.get(p).declarationSpec.filter(typeof(TypeSpecifier)).map[type].head
			var hasPointer = params.get(p).declarator?.point
			if(hasPointer !=null) typeDecl = typeDecl+'*';
			
			var typeCall = parameters.get(p).findType
			if(typeDecl != typeCall) {
				error("Parameters types are incompatible.",
					StdcPackage.Literals.FUNCTION_CALL__PARAMS,
					INVALID_NAME)
			}
		}
	}
	
	@Check
	def checkTypeFunctionAndReturn(FunctionDefinition f) {
		var typeF = f.declarationSpec.filter(typeof(TypeSpecifier)).map[type].head;
		var hasPointer = f.decla.point
		if(hasPointer !=null) typeF = typeF+'*';
		var returnExp = f.returnStatement?.head.expR?.postExp
		if(returnExp != null) { 
			if( returnExp instanceof PostfixExpression) {
				returnExp = (returnExp as PostfixExpression).primaryExp
			}
		}
		var typeR = returnExp?.typeActual
		var ok = true
		if(typeF == 'void' && typeR != null) ok = false
		else if(typeF != 'void' && typeR == null) ok = false
		else if(typeF == 'char*' && typeR != 'char*') ok = false
		else if(typeF == 'char' && typeR != 'char') ok = false
		else if(typeF != 'char*' && typeR == 'char*') ok = false
		if(!ok) {
			error("The return type is incompatible. Expected '"+typeF+
				"' but was '"+typeR+"'",StdcPackage.Literals.FUNCTION_DEFINITION__DECLARATION_SPEC,
				INVALID_NAME)
		}
	}
	
	@Check 
	def checkValidTypesFunction(FunctionDefinition f) {
		val ntypes = f.declarationSpec.filter(typeof(TypeSpecifier)).map[type];
		var ok = false;
		var totalL = 0;
		var totalO = 0;
		if(ntypes.size > 1 || ntypes.size <= 3) {
			for(t : ntypes) {
				if(t == 'long') totalL++;
				if(t == 'unsigned') totalO++;
				if(t == 'signed') totalO++;
			}
		}
		if((totalL <= 2 || totalO <= 1) && (totalL+totalO+1) == ntypes.size ) ok = true;
		
		if(ntypes.size == 1 && ntypes.head!='unsigned' && ntypes.head!='signed' ) ok =true; 
		
		if(!ok) {
			error('Two or more data types in declaration specifiers',StdcPackage.Literals.FUNCTION_DEFINITION__DECLARATION_SPEC,
				INVALID_NAME)
		}
	}
	
	@Check 
	def checkTypesDeclaration(DeclarationInitDeclaratorList d) {
		val ntypes = d.declarationSpec.filter(typeof(TypeSpecifier)).map[type];
		var ok = false;
		var totalL = 0;
		var totalO = 0;
		if(ntypes.size > 1 || ntypes.size <= 3) {
			for(t : ntypes) {
				if(t == 'long') totalL++;
				if(t == 'unsigned') totalO++;
				if(t == 'signed') totalO++;
			}
		}
		if((totalL <= 2 || totalO <= 1) && (totalL+totalO+1) == ntypes.size ) ok = true;
		if(ntypes.size == 1 && ntypes.head!='unsigned' && ntypes.head!='signed' ) ok =true;
		if(!ok) {
			error('Two or more data types in declaration specifiers',StdcPackage.Literals.DECLARATION_INIT_DECLARATOR_LIST__DECLARATION_SPEC,
				INVALID_NAME)
		}
	}
	
	@Check
	def checkTypes(ExpressionC exp) {
		var expected = exp.expectedType
		var actual = exp.findType
		if(expected == null || actual == null) return;
		if((expected == 'char*' && actual != 'char*') ||
		 (expected != 'char*' && actual == 'char*') ||
		 (expected == 'char' && actual != 'char'))  {
			error("Types are incompatible. Expected '"+expected+
					"' but was '"+actual+"'",
					StdcPackage.Literals.EXPRESSION_C__POST_EXP,
					INVALID_NAME)
		}
	}

	@Check
	def checkDeclarationsConstraints(DeclarationInitDeclaratorList d) {
		val type = d.declarationSpec.filter(typeof(TypeSpecifier)).map[type].head;
		if(type != null && type == 'void') {
			error("Is not possible to declare a variable or field as void",
					StdcPackage.Literals.EXPRESSION_C__POST_EXP,
					INVALID_NAME)
		}
		
	}

	@Check
	def checkAssignmentsAndDeclarationConstraints(ExpressionC e) {
		val c = e.eContainer
		val f = e.eContainingFeature
		if(c instanceof AssignmentExpression) {
			if(f == StdcPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT) {
				val leftExp=c.left.findPrimaryExp
				//Verifica se a assignment expression eh atribuida a um ID
				if(!(leftExp instanceof Identifier)) {
					error('The assigned variable is not an Identifier',StdcPackage.Literals.EXPRESSION_C__UN_EXP,
				INVALID_NAME)
				}
				//verifica so o ID ja foi declarado
				else if(leftExp instanceof Identifier) {
					val previousDecl = leftExp.idType
					if(previousDecl == null) {
						error("Variable '"+leftExp.name+"' was not previously declared",StdcPackage.Literals.EXPRESSION_C__UN_EXP,
							INVALID_NAME)
					} 
				}
				
				val id = e.findPrimaryExp
				if(id instanceof Identifier) {
					if(id.idType == null) {
						error("Variable '"+id.name+"' was not previously declared",StdcPackage.Literals.EXPRESSION_C__UN_EXP,
							INVALID_NAME)
					}
				}
			}
		}
		else if(c instanceof Initializer) {
			if(f == StdcPackage.Literals.INITIALIZER__EXP) {
				val id = e.findPrimaryExp
				if(id instanceof Identifier) {
					if(id.idType == null) {
						error("Variable '"+id.name+"' was not previously declared",StdcPackage.Literals.EXPRESSION_C__UN_EXP,
							INVALID_NAME)
					}
				}			
			}
		}
	}
	
	@Check
	def checkDoWhileCond(DoWhileLoop loop) {
		var predicate = loop.cond?.findPrimaryExp
		if(predicate instanceof Identifier) {
			if(predicate.idType == null) {
				error("Variable '"+predicate.name+"' was not previously declared",
					StdcPackage.Literals.DO_WHILE_LOOP__COND, INVALID_NAME)				
			}
		}
	}

	@Check
	def void checkNoDuplicateVariable(DirectDeclarator vardecl) {
		val method = vardecl.containingMethod
		var ok = true;
		if(method != null) {
			var duplicate = method.body.
				getAllContentsOfType(typeof(DirectDeclarator)).findFirst[
					it != vardecl && it.name == vardecl.name		
				]
			if(duplicate != null) ok = false;
		}
		if(ok) {
			var duplicate = vardecl.containingClass.exDeclaration.filter(
				typeof(DeclarationInitDeclaratorList)
			).findFirst[
						if(it.declaratorList.iniDec!=null){	
							(it.declaratorList.iniDec.dec.directDecl.name == vardecl.name 
								&& it.declaratorList.iniDec.dec.directDecl != vardecl)
						}
						else {
							(it.declaratorList as InitDeclaList).getAllContentsOfType(typeof(DirectDeclarator)).findFirst[
								it != vardecl && it.name == vardecl.name]?.name == vardecl.name
						}
					]
			if(duplicate != null) ok = false;
		}
		if (!ok)
			error("Conflicting declaration '" + vardecl.name + "'",
				StdcPackage.Literals.DIRECT_DECLARATOR__NAME,
				DUPLICATE_ELEMENT
			)
	}
	
	@Check
	def void checkDuplicateMethod(FunctionDefinition f) {
		val fname = f.decla.directDecl.name
		val overridden = f.containingClass.exDeclaration.
			filter(typeof(FunctionDefinition)).findFirst[it != f && it.decla.directDecl.name == fname]
		
		if (overridden != null) {
				error('"The function '+fname+' must have a different name"',
					StdcPackage.Literals.FUNCTION_DEFINITION__DECLA,
					FUNCTION_DUPLICATE
				)
		}
	}	
}
